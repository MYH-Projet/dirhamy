name: Dirhamy CI/CD

on:
  push:
    branches: ["develop", "master"]
  pull_request:
    branches: ["develop"]

env:
  REGISTRY: docker.io
  IMAGE_BACKEND: mba1342004/dirhamy-backend
  IMAGE_FRONTEND: mba1342004/dirhamy-frontend

jobs:
  # -------------------------
  # 1) CI - Tests backend
  # -------------------------
  tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install deps (backend)
        working-directory: ./backend
        run: npm ci

      # .env généré à partir des secrets (ne jamais le commit)
      - name: Create backend .env (CI)
        working-directory: ./backend
        shell: bash
        run: |
          cat > .env <<EOF
          DATABASE_URL=postgresql://postgres:postgres@db:5432/dirhamy
          PORT=3000
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          REFRESH_TOKEN_SECRET=${{ secrets.REFRESH_TOKEN_SECRET }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          GMAIL=${{ secrets.GMAIL }}
          GMAIL_PASS=${{ secrets.GMAIL_PASS }}
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          REDIS_URL=redis
          EOF

      # Optionnel: vérifier docker si tes tests démarrent une DB via containers
      - name: Docker info (optional)
        run: docker info

      - name: Run tests
        working-directory: ./backend
        run: npm test

  # -------------------------
  # 2) CI - build & push images
  # -------------------------
  build-and-push:
    runs-on: ubuntu-latest
    needs: tests
    if: github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master')

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Cache build (facultatif mais recommandé)
      - name: Build & push backend (latest + develop)
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_BACKEND }}:latest
            ${{ env.IMAGE_BACKEND }}:develop
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push frontend (latest + develop)
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          build-args: |
            VITE_API_URL=/api
            NODE_ENV=production
          tags: |
            ${{ env.IMAGE_FRONTEND }}:latest
            ${{ env.IMAGE_FRONTEND }}:develop
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # -------------------------
  # 3) CD - deploy on EC2 (master)
  # -------------------------
  deploy-prod:
    runs-on: ubuntu-latest
    needs: [tests, build-and-push]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'

    steps:
      - name: Configure SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}

      - name: Add EC2 host key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "${{ secrets.EC2_HOST }}" >> ~/.ssh/known_hosts

      # Option A (recommandée): le .env est déjà présent sur l’EC2, on ne le touche pas.
      # Option B: on pousse/écrit le .env depuis GitHub Secrets sur l’EC2 (ci-dessous).
      - name: Deploy (write .env + pull + up)
        shell: bash
        run: |
          ssh ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ~/dirhamy

            # Ecrire/mettre à jour le .env sur le serveur
            cat > .env <<EOT
            DATABASE_URL=postgresql://postgres:postgres@db:5432/dirhamy
            PORT=3000
            JWT_SECRET='${{ secrets.JWT_SECRET }}'
            REFRESH_TOKEN_SECRET='${{ secrets.REFRESH_TOKEN_SECRET }}'
            GEMINI_API_KEY='${{ secrets.GEMINI_API_KEY }}'
            GMAIL='${{ secrets.GMAIL }}'
            GMAIL_PASS='${{ secrets.GMAIL_PASS }}'
            REDIS_PORT=6379
            REDIS_PASSWORD='${{ secrets.REDIS_PASSWORD }}'
            REDIS_URL=redis
            EOT

            docker compose -f docker-compose.prod.yml pull
            docker compose -f docker-compose.prod.yml up -d

            docker image prune -f
          EOF
